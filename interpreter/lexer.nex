/[ \t]/  { /* Skip blanks and tabs. */ }
/\/\// {/*Comment so let's skip it*/ yylex.stack = yylex.stack[:len(yylex.stack)-1];yylex.Stop()}
/get/ {  printToks("TOK_GET"); return TOK_GET}
/getu/ {  printToks("TOK_GETU"); return TOK_GETU}
/getslot/ {  printToks("TOK_GETSLOT"); return TOK_GETSLOT}
/search/ { printToks("TOK_SEARCH"); return TOK_SEARCH}
/hc/ { printToks("TOK_HIERARCH"); return TOK_HIERARCH}
/\+/ { printToks("TOK_PLUS");lval.s = yylex.Text(); return TOK_PLUS}
/-/ {  printToks("TOK_MINUS");lval.s = yylex.Text(); return TOK_MINUS}

/:/ {  printToks("TOK_COL"); return TOK_COL}
/@/ {  printToks("TOK_ATTRSPEC"); return TOK_ATTRSPEC}
/\$/ { printToks("TOK_DEREF"); return TOK_DEREF}
/;/ { printToks("TOK_SEMICOL"); return TOK_SEMICOL}
/\[/ {  printToks("TOK_LBLOCK"); return TOK_LBLOCK}
/\]/ {  printToks("TOK_RBLOCK"); return TOK_RBLOCK}
/\(/ {  printToks("TOK_LPAREN"); return TOK_LPAREN}
/\)/ {  printToks("TOK_RPAREN"); return TOK_RPAREN}
/\|\|/ {  printToks("TOK_OR"); return TOK_OR}
/&&/ {  printToks("TOK_AND"); return TOK_AND}
/\!=/ {  printToks("TOK_NOT_EQUAL"); return TOK_NOT_EQUAL}
/\!/ {  printToks("TOK_NOT"); return TOK_NOT}
/\*/ {  printToks("TOK_MULT"); return TOK_MULT}
/%/  { printToks("TOK_MOD"); return TOK_MOD}
/>=/ {  printToks("TOK_GREATER_EQUAL"); return TOK_GREATER_EQUAL}
/<=/ {  printToks("TOK_LESS_EQUAL"); return TOK_LESS_EQUAL}
/>/ {  printToks("TOK_GREATER"); return TOK_GREATER}
/</ {  printToks("TOK_LESS"); return TOK_LESS}
/true/ {  printToks("TOK_TRUE"); return TOK_TRUE}
/false/ {  printToks("TOK_FALSE"); return TOK_FALSE}
/if/ {  printToks("TOK_IF"); return TOK_IF}
/for/ {  printToks("TOK_FOR"); return TOK_FOR}
/in/ {  printToks("TOK_IN"); return TOK_IN}
/while/ {  printToks("TOK_WHILE"); return TOK_WHILE}
/else/ {  printToks("TOK_ELSE"); return TOK_ELSE}
/then/ {  printToks("TOK_THEN"); return TOK_THEN}
/fi/ {  printToks("TOK_FI"); return TOK_FI}
/elif/ {  printToks("TOK_ELIF"); return TOK_ELIF}
/done/ {  printToks("TOK_DONE"); return TOK_DONE}
/do/ {  printToks("TOK_DO"); return TOK_DO}
/print/ {  printToks("TOK_PRNT"); return TOK_PRNT}
/unset/ {  printToks("TOK_UNSET"); return TOK_UNSET}
/\"/ {  printToks("TOK_QUOT"); return TOK_QUOT}

/selection/ {  printToks("TOK_SELECT"); return TOK_SELECT}
/.cmds/ {  printToks("TOK_CMDS"); return TOK_CMDS}
/.template/ {  printToks("TOK_TEMPLATE"); return TOK_TEMPLATE}
/.var/ {  printToks("TOK_VAR");return TOK_VAR}
/.env/ {  printToks("TOK_SETENV");return TOK_SETENV}
/{/ {  printToks("TOK_LBRAC");return TOK_LBRAC}
/}/ {  printToks("TOK_RBRAC");return TOK_RBRAC}
/,/ {  printToks("TOK_COMMA"); return TOK_COMMA}
/\.\./ {  printToks("TOK_DOT_DOT"); return TOK_DOT_DOT}
/\./ {printToks("TOK_DOT"); return TOK_DOT}
/usJn/ {  printToks("TOK_USE_JSON"); return TOK_USE_JSON}
/partial/ {  printToks("TOK_PARTIAL"); return TOK_PARTIAL}
/ui.delay/ { printToks("TOK_UI_DELAY"); return TOK_UI_DELAY}
/ui.wireframe/ { printToks("TOK_UI_WIREFRAME"); return TOK_UI_WIREFRAME}
/ui.infos/ { printToks("TOK_UI_INFOS"); return TOK_UI_INFOS}
/ui.debug/ { printToks("TOK_UI_DEBUG"); return TOK_UI_DEBUG}
/ui.highlight/ { printToks("TOK_UI_HIGHLIGHT"); return TOK_UI_HIGHLIGHT}
/ui.hl/ { printToks("TOK_UI_HIGHLIGHT"); return TOK_UI_HIGHLIGHT}
/camera.move/ { printToks("TOK_CAM_MOVE"); return TOK_CAM_MOVE}
/camera.wait/ { printToks("TOK_CAM_WAIT"); return TOK_CAM_WAIT}
/camera.translate/ { printToks("TOK_CAM_TRANSLATE"); return TOK_CAM_TRANSLATE}
/camera/ { printToks("TOK_CAM"); return TOK_CAM}
/ui/ { printToks("TOK_UI"); return TOK_UI}
/orphan/ { printToks("TOK_ORPH"); return TOK_ORPH}
/link/ { printToks("TOK_LINK"); return TOK_LINK}
/unlink/ { printToks("TOK_UNLINK"); return TOK_UNLINK}

/tenant|tn/ {  printToks("TOK_TENANT");lval.s = yylex.Text();return TOK_TENANT}
/site|si/ {  printToks("TOK_SITE");lval.s = yylex.Text();return TOK_SITE}
/bldg|building|bd/ {  printToks("TOK_BLDG");lval.s = yylex.Text();return TOK_BLDG}
/room|ro/ {  printToks("TOK_ROOM");lval.s = yylex.Text();return TOK_ROOM}
/rack|rk/ {  printToks("TOK_RACK");lval.s = yylex.Text();return TOK_RACK}
/device|dv/ {  printToks("TOK_DEVICE");lval.s = yylex.Text();return TOK_DEVICE}
/group|gp/ {  printToks("TOK_GROUP");lval.s = yylex.Text();return TOK_GROUP}
/corridor|co/ {  printToks("TOK_CORIDOR");lval.s = yylex.Text();return TOK_CORIDOR}
/ac/ {  printToks("TOK_AC");lval.s = yylex.Text();return TOK_AC}
/panel|pn/ {  printToks("TOK_PANEL");lval.s = yylex.Text();return TOK_PANEL}
/cabinet|cb/ {  printToks("TOK_CABINET");lval.s = yylex.Text();return TOK_CABINET}
/sensor|sr/ {  printToks("TOK_SENSOR");lval.s = yylex.Text();return TOK_SENSOR}
/room_template/ {  printToks("TOK_ROOM_TMPL");lval.s = yylex.Text();return TOK_ROOM_TMPL}
/obj_template/ {  printToks("TOK_OBJ_TMPL");lval.s = yylex.Text();return TOK_OBJ_TMPL}

/([0-9][0-9 ]*)/ {  printToks("TOK_INT");lval.n = atoi(yylex.Text()); return TOK_INT}
/[0-9]+\.[0-9]+/ { printToks("TOK_FLOAT");lval.f, _ = strconv.ParseFloat((yylex.Text()), 64); return TOK_FLOAT }
/lsten/ {  printToks("TOK_LSTEN"); return TOK_LSTEN}
/lssite/ {  printToks("TOK_LSSITE"); return TOK_LSSITE}
/lsbldg/ {  printToks("TOK_LSBLDG"); return TOK_LSBLDG}
/lsroom/ {  printToks("TOK_LSROOM"); return TOK_LSROOM}
/lsrack/ {  printToks("TOK_LSRACK"); return TOK_LSRACK}
/lsdev/ {  printToks("TOK_LSDEV"); return TOK_LSDEV}
/lscabinet/ {  printToks("TOK_LSCAB"); return TOK_LSCAB}
/lssensor/ {  printToks("TOK_LSSENSOR"); return TOK_LSSENSOR}
/lsac/ {  printToks("TOK_LSAC"); return TOK_LSAC}
/lspanel/ {  printToks("TOK_LSPANEL"); return TOK_LSPANEL}
/lscorridor/ {  printToks("TOK_LSCORRIDOR"); return TOK_LSCORRIDOR}
/lsu/ {  printToks("TOK_LSU"); return TOK_LSU}
/lsslot/ {  printToks("TOK_LSSLOT"); return TOK_LSSLOT}
/lsenterprise/ {  printToks("TOK_LSENTERPRISE"); return TOK_LSENTERPRISE}
/tree/ { printToks("TOK_TREE"); return TOK_TREE}
/lsog/ { printToks("TOK_LSOG"); return TOK_LSOG}
/env/ { printToks("TOK_ENV"); return TOK_ENV}
/cd/ { printToks("TOK_CD");return TOK_CD}
/pwd/ { printToks("TOK_PWD");return TOK_PWD}
/clear/ { printToks("TOK_CLR");return TOK_CLR}
/grep/ { printToks("TOK_GREP");return TOK_GREP}
/ls/ { printToks("TOK_LS");return TOK_LS}
/exit/ { printToks("TOK_EXIT"); return TOK_EXIT}
/len/ { printToks("TOK_LEN"); return TOK_LEN}
/[^=!]([=!]=)[^=]/ { printToks("TOK_DOUBLE_EQUAL");return TOK_DOUBLE_EQUAL}
/[=]/ { printToks("TOK_EQUAL");return TOK_EQUAL}
/\// { printToks("TOK_SLASH"); return TOK_SLASH}
/man/ { printToks("TOK_DOC"); return TOK_DOC}
/drawable/ { printToks("TOK_DRAW"); return TOK_DRAWABLE}
/draw/ { printToks("TOK_DRAW"); return TOK_DRAW}
/"[^"]*"/ {printToks("TOK_STR"); lval.s = yylex.Text()[1:len(yylex.Text())-1]; return TOK_STR}
/[\+\-]?[NSEW][\+\-]?[NSEW]/ {printToks("TOK_ORIENTATION"); lval.s = yylex.Text(); printCapturedWord(lval.s); return TOK_ORIENTATION}
/[\.A-Za-z0-9_][\.A-Za-z0-9_\)\(\-]*/ { printToks("TOK_WORD"); lval.s = yylex.Text(); printCapturedWord(lval.s); return TOK_WORD}
//
package main
import (
	"strconv"
	cmd "cli/controllers"
)
type TOKType int

func atoi(x string) int {
	v, e := strconv.Atoi(strings.ReplaceAll(x, " ", ""))
	if e != nil {
		println("STRCONV ERROR! " + x)
		return 0
	}
	return v
}

func printToks(tok string) {
	if cmd.State.DebugLvl >= 3 {
		println("We got ", tok)
	}
}

func printCapturedWord(x string) {
	if cmd.State.DebugLvl >= 3 {
		println("LVAL: ", x)
	}
}