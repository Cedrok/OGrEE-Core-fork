/[ \t]/  { /* Skip blanks and tabs. */ }
/create/ {printToks("TOK_CREATE");return TOK_CREATE}
/gt/ { printToks("TOK_GET"); return TOK_GET}
/update/ {printToks("TOK_UPDATE"); return TOK_UPDATE}
/delete/ {printToks("TOK_DELETE"); return TOK_DELETE}
/search/ {printToks("TOK_SEARCH"); return TOK_SEARCH}
/\+/ {printToks("TOK_PLUS");lval.s = yylex.Text(); return TOK_PLUS}
/-/ { printToks("TOK_OCDEL");lval.s = yylex.Text(); return TOK_OCDEL}
/:/ { printToks("TOK_COL"); return TOK_COL}
/@/ { printToks("TOK_ATTRSPEC"); return TOK_ATTRSPEC}
/\$/ {printToks("TOK_DEREF"); return TOK_DEREF}
/;/ {printToks("TOK_SEMICOL"); return TOK_SEMICOL}
/\[/ { printToks("TOK_LBLOCK"); return TOK_LBLOCK}
/\]/ { printToks("TOK_RBLOCK"); return TOK_RBLOCK}
/\(/ { printToks("TOK_LPAREN"); return TOK_LPAREN}
/\)/ { printToks("TOK_RPAREN"); return TOK_RPAREN}
/||/ { printToks("TOK_OR"); return TOK_OR}
/&&/ { printToks("TOK_AND"); return TOK_AND}
/\!/ { printToks("TOK_NOT"); return TOK_NOT}
/\*/ { printToks("TOK_MULT"); return TOK_MULT}
/>/ { printToks("TOK_GREATER"); return TOK_GREATER}
/</ { printToks("TOK_LESS"); return TOK_LESS}
/false|true/ { printToks("TOK_BOOL");lval.s = yylex.Text(); return TOK_BOOL}
/if/ { printToks("TOK_IF"); return TOK_IF}
/for/ { printToks("TOK_FOR"); return TOK_FOR}
/in/ { printToks("TOK_IN"); return TOK_IN}
/while/ { printToks("TOK_WHILE"); return TOK_WHILE}
/else/ { printToks("TOK_ELSE"); return TOK_ELSE}
/then/ { printToks("TOK_THEN"); return TOK_THEN}
/fi/ { printToks("TOK_FI"); return TOK_FI}
/elif/ { printToks("TOK_ELIF"); return TOK_ELIF}
/done/ { printToks("TOK_DONE"); return TOK_DONE}
/do/ { printToks("TOK_DO"); return TOK_DO}
/print/ { printToks("TOK_PRNT"); return TOK_PRNT}
/unset/ { printToks("TOK_UNSET"); return TOK_UNSET}
/\"/ { printToks("TOK_QUOT"); return TOK_QUOT}

/tn/ { printToks("TOK_OCTENANT");return TOK_OCTENANT}
/si/ { printToks("TOK_OCSITE");return TOK_OCSITE}
/bd/ { printToks("TOK_OCBLDG");return TOK_OCBLDG}
/ro/ { printToks("TOK_OCROOM");return TOK_OCROOM}
/rk/ { printToks("TOK_OCRACK");return TOK_OCRACK}
/dv/ { printToks("TOK_OCDEV");return TOK_OCDEV}
/gr/ { printToks("TOK_OCGROUP");return TOK_OCGROUP}
/wa/ { printToks("TOK_OCWALL");return TOK_OCWALL}
/co/ { printToks("TOK_OCCORIDOR");return TOK_OCCORIDOR}
/selection/ { printToks("TOK_SELECT"); return TOK_SELECT}
/cmds/ { printToks("TOK_CMDS"); return TOK_CMDS}
/template/ { printToks("TOK_TEMPLATE"); return TOK_TEMPLATE}
/var/ { printToks("TOK_VAR");return TOK_VAR}
/{/ { printToks("TOK_LBRAC");return TOK_LBRAC}
/}/ { printToks("TOK_RBRAC");return TOK_RBRAC}
/,/ { printToks("TOK_COMMA"); return TOK_COMMA}
/\./ { printToks("TOK_DOT"); return TOK_DOT}

/tenant/ { printToks("TOK_TENANT");lval.s = yylex.Text();return TOK_TENANT}
/site/ { printToks("TOK_SITE");lval.s = yylex.Text();return TOK_SITE}
/bldg|building/ { printToks("TOK_BLDG");lval.s = yylex.Text();return TOK_BLDG}
/room/ { printToks("TOK_ROOM");lval.s = yylex.Text();return TOK_ROOM}
/rack/ { printToks("TOK_RACK");lval.s = yylex.Text();return TOK_RACK}
/device/ { printToks("TOK_DEVICE");lval.s = yylex.Text();return TOK_DEVICE}
/group/ { printToks("TOK_GROUP");lval.s = yylex.Text();return TOK_GROUP}
/corridor/ { printToks("TOK_CORIDOR");lval.s = yylex.Text();return TOK_CORIDOR}
/wall/ { printToks("TOK_WALL");lval.s = yylex.Text();return TOK_WALL}

/[0-9]+/ { printToks("TOK_NUM");lval.n = atoi(yylex.Text()); return TOK_NUM}
/lsten/ { printToks("TOK_LSTEN"); return TOK_LSTEN}
/lssite/ { printToks("TOK_LSSITE"); return TOK_LSSITE}
/lsbldg/ { printToks("TOK_LSBLDG"); return TOK_LSBLDG}
/lsroom/ { printToks("TOK_LSROOM"); return TOK_LSROOM}
/lsrack/ { printToks("TOK_LSRACK"); return TOK_LSRACK}
/lsdev/ { printToks("TOK_LSDEV"); return TOK_LSDEV}
/tree/ {printToks("TOK_TREE"); return TOK_TREE}
/lsog/ {printToks("TOK_LSOG"); return TOK_LSOG}
/cd/ {printToks("TOK_CD");return TOK_CD}
/pwd/ {printToks("TOK_PWD");return TOK_PWD}
/clear/ {printToks("TOK_CLR");return TOK_CLR}
/grep/ {printToks("TOK_GREP");return TOK_GREP}
/ls/ {printToks("TOK_LS");return TOK_LS}
/exit/ {printToks("TOK_EXIT"); return TOK_EXIT}
/len/ {printToks("TOK_LEN"); return TOK_LEN}
/-l/ {printToks("TOK_CMDFLAG");return TOK_CMDFLAG}
/[=]/ {printToks("TOK_EQUAL");return TOK_EQUAL}
/\// {printToks("TOK_SLASH"); return TOK_SLASH}
/man/ {printToks("TOK_DOC"); return TOK_DOC}
/[A-Za-z0-9_]+/ {printToks("TOK_WORD"); lval.s = yylex.Text(); printCapturedWord(lval.s); return TOK_WORD}
//
package main
import (
	"os"
	"strconv"
	cmd "cli/controllers"
)
type TOKType int

func atoi(x string) int {
	v, e := strconv.Atoi(x)
	if e != nil {
		println("STRCONV ERROR!")
		return 0
	}
	return v
}

func printToks(tok string) {
	if cmd.State.DebugLvl >= 2 {
		println("We got ", tok)
	}
}

func printCapturedWord(x string) {
	if cmd.State.DebugLvl >= 2 {
		println("LVAL: ", x)
	}
}

func lexBegin() {
  //NN_FUN(NewLexer(os.Stdin))
  //yyParse(NewLexer(os.Stdin))

  	lex := NewLexer(strings.NewReader(os.Args[1]))
	e := yyParse(lex)
	println("Return Code: ", e)
}