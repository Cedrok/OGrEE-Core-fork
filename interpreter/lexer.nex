/[ \t]/  { /* Skip blanks and tabs. */ }
/create/ { printToks("TOK_CREATE");return TOK_CREATE}
/gt/ {  printToks("TOK_GET"); return TOK_GET}
/update/ { printToks("TOK_UPDATE"); return TOK_UPDATE}
/delete/ { printToks("TOK_DELETE"); return TOK_DELETE}
/search/ { printToks("TOK_SEARCH"); return TOK_SEARCH}
/hc/ { printToks("TOK_HIERARCH"); return TOK_HIERARCH}
/\+/ { printToks("TOK_PLUS");lval.s = yylex.Text(); return TOK_PLUS}

/-/ {  printToks("TOK_OCDEL");lval.s = yylex.Text(); return TOK_OCDEL}


/:/ {  printToks("TOK_COL"); return TOK_COL}
/@/ {  printToks("TOK_ATTRSPEC"); return TOK_ATTRSPEC}
/\$/ { printToks("TOK_DEREF"); return TOK_DEREF}
/;/ { printToks("TOK_SEMICOL"); return TOK_SEMICOL}
/\[/ {  printToks("TOK_LBLOCK"); return TOK_LBLOCK}
/\]/ {  printToks("TOK_RBLOCK"); return TOK_RBLOCK}
/\(/ {  printToks("TOK_LPAREN"); return TOK_LPAREN}
/\)/ {  printToks("TOK_RPAREN"); return TOK_RPAREN}
/\|\|/ {  printToks("TOK_OR"); return TOK_OR}
/&&/ {  printToks("TOK_AND"); return TOK_AND}
/\!/ {  printToks("TOK_NOT"); return TOK_NOT}
/\*/ {  printToks("TOK_MULT"); return TOK_MULT}
/%/  { printToks("TOK_MOD"); return TOK_MOD}
/>/ {  printToks("TOK_GREATER"); return TOK_GREATER}
/</ {  printToks("TOK_LESS"); return TOK_LESS}
/false|true/ {  printToks("TOK_BOOL");lval.s = yylex.Text(); return TOK_BOOL}
/if/ {  printToks("TOK_IF"); return TOK_IF}
/for/ {  printToks("TOK_FOR"); return TOK_FOR}
/in/ {  printToks("TOK_IN"); return TOK_IN}
/while/ {  printToks("TOK_WHILE"); return TOK_WHILE}
/else/ {  printToks("TOK_ELSE"); return TOK_ELSE}
/then/ {  printToks("TOK_THEN"); return TOK_THEN}
/fi/ {  printToks("TOK_FI"); return TOK_FI}
/elif/ {  printToks("TOK_ELIF"); return TOK_ELIF}
/done/ {  printToks("TOK_DONE"); return TOK_DONE}
/do/ {  printToks("TOK_DO"); return TOK_DO}
/print/ {  printToks("TOK_PRNT"); return TOK_PRNT}
/unset/ {  printToks("TOK_UNSET"); return TOK_UNSET}
/\"/ {  printToks("TOK_QUOT"); return TOK_QUOT}

/selection/ {  printToks("TOK_SELECT"); return TOK_SELECT}
/cmds/ {  printToks("TOK_CMDS"); return TOK_CMDS}
/template/ {  printToks("TOK_TEMPLATE"); return TOK_TEMPLATE}
/var/ {  printToks("TOK_VAR");return TOK_VAR}
/{/ {  printToks("TOK_LBRAC");return TOK_LBRAC}
/}/ {  printToks("TOK_RBRAC");return TOK_RBRAC}
/,/ {  printToks("TOK_COMMA"); return TOK_COMMA}
/\./ {  printToks("TOK_DOT"); return TOK_DOT}
/usJn/ {  printToks("TOK_USE_JSON"); return TOK_USE_JSON}
/partial/ {  printToks("TOK_PARTIAL"); return TOK_PARTIAL}
/ui/ { printToks("TOK_UI"); return TOK_UI}
/camera/ { printToks("TOK_CAM"); return TOK_CAM}
/orphan/ { printToks("TOK_ORPH"); return TOK_ORPH}
/link/ { printToks("TOK_LINK"); return TOK_LINK}
/unlink/ { printToks("TOK_UNLINK"); return TOK_UNLINK}

/tenant|tn/ {  printToks("TOK_TENANT");lval.s = yylex.Text();return TOK_TENANT}
/site|si/ {  printToks("TOK_SITE");lval.s = yylex.Text();return TOK_SITE}
/bldg|building|bd/ {  printToks("TOK_BLDG");lval.s = yylex.Text();return TOK_BLDG}
/room|ro/ {  printToks("TOK_ROOM");lval.s = yylex.Text();return TOK_ROOM}
/rack|rk/ {  printToks("TOK_RACK");lval.s = yylex.Text();return TOK_RACK}
/device|dv/ {  printToks("TOK_DEVICE");lval.s = yylex.Text();return TOK_DEVICE}
/group|gp/ {  printToks("TOK_GROUP");lval.s = yylex.Text();return TOK_GROUP}
/corridor|co/ {  printToks("TOK_CORIDOR");lval.s = yylex.Text();return TOK_CORIDOR}
/separator|sp/ {  printToks("TOK_WALL");lval.s = yylex.Text();return TOK_WALL}
/ac/ {  printToks("TOK_AC");lval.s = yylex.Text();return TOK_AC}
/panel|pn/ {  printToks("TOK_PANEL");lval.s = yylex.Text();return TOK_PANEL}
/tile|tl/ {  printToks("TOK_TILE");lval.s = yylex.Text();return TOK_TILE}
/row/ {  printToks("TOK_ROW");lval.s = yylex.Text();return TOK_ROW}
/cabinet|cb/ {  printToks("TOK_CABINET");lval.s = yylex.Text();return TOK_CABINET}
/sensor|sr/ {  printToks("TOK_SENSOR");lval.s = yylex.Text();return TOK_SENSOR}
/room_template/ {  printToks("TOK_ROOM_TMPL");lval.s = yylex.Text();return TOK_ROOM_TMPL}
/obj_template/ {  printToks("TOK_OBJ_TMPL");lval.s = yylex.Text();return TOK_OBJ_TMPL}

/([0-9]+)/ {  printToks("TOK_NUM");lval.n = atoi(yylex.Text()); return TOK_NUM}
/[0-9]+\.[0-9]+/ { printToks("TOK_FLOAT");lval.f, _ = strconv.ParseFloat((yylex.Text()), 64); return TOK_FLOAT }
/lsten/ {  printToks("TOK_LSTEN"); return TOK_LSTEN}
/lssite/ {  printToks("TOK_LSSITE"); return TOK_LSSITE}
/lsbldg/ {  printToks("TOK_LSBLDG"); return TOK_LSBLDG}
/lsroom/ {  printToks("TOK_LSROOM"); return TOK_LSROOM}
/lsrack/ {  printToks("TOK_LSRACK"); return TOK_LSRACK}
/lsdev/ {  printToks("TOK_LSDEV"); return TOK_LSDEV}
/lsrow/ {  printToks("TOK_LSROW"); return TOK_LSROW}
/lstile/ {  printToks("TOK_LSTILE"); return TOK_LSTILE}
/lscabinet/ {  printToks("TOK_LSCAB"); return TOK_LSCAB}
/lssensor/ {  printToks("TOK_LSSENSOR"); return TOK_LSSENSOR}
/lsac/ {  printToks("TOK_LSAC"); return TOK_LSAC}
/lspanel/ {  printToks("TOK_LSPANEL"); return TOK_LSPANEL}
/lsseparator/ {  printToks("TOK_LSWALL"); return TOK_LSWALL}
/lscorridor/ {  printToks("TOK_LSCORRIDOR"); return TOK_LSCORRIDOR}
/tree/ { printToks("TOK_TREE"); return TOK_TREE}
/lsog/ { printToks("TOK_LSOG"); return TOK_LSOG}
/env/ { printToks("TOK_ENV"); return TOK_ENV}
/cd/ { printToks("TOK_CD");return TOK_CD}
/pwd/ { printToks("TOK_PWD");return TOK_PWD}
/clear/ { printToks("TOK_CLR");return TOK_CLR}
/grep/ { printToks("TOK_GREP");return TOK_GREP}
/ls/ { printToks("TOK_LS");return TOK_LS}
/exit/ { printToks("TOK_EXIT"); return TOK_EXIT}
/len/ { printToks("TOK_LEN"); return TOK_LEN}
/[=]/ { printToks("TOK_EQUAL");return TOK_EQUAL}
/\// { printToks("TOK_SLASH"); return TOK_SLASH}
/man/ { printToks("TOK_DOC"); return TOK_DOC}
/drawable/ { printToks("TOK_DRAW"); return TOK_DRAWABLE}
/draw/ { printToks("TOK_DRAW"); return TOK_DRAW}
/"[^"]+"/ {printToks("TOK_STR"); lval.s = yylex.Text()[1:len(yylex.Text())-1]; return TOK_STR}
/[A-Za-z0-9_][A-Za-z0-9_\-]*/ { printToks("TOK_WORD"); lval.s = yylex.Text(); printCapturedWord(lval.s); return TOK_WORD}
//
package main
import (
	"strconv"
	cmd "cli/controllers"
)
type TOKType int


func atoi(x string) int {
	v, e := strconv.Atoi(x)
	if e != nil {
		println("STRCONV ERROR!")
		return 0
	}
	return v
}

func printToks(tok string) {
	if cmd.State.DebugLvl >= 2 {
		println("We got ", tok)
	}
}

func printCapturedWord(x string) {
	if cmd.State.DebugLvl >= 2 {
		println("LVAL: ", x)
	}
}